#  PDFinder
Приложение позволяет быстро скачивать и искать PDF-документы просто сканируя штрих-коды.

##Возможности:
- Сканирование штрих-кодов для поиска документов
- Последующий вывод документа, если тот найден в локальной базе данных
- Скачивание документа с подключённого сервера, если не найде локальная копия, или выбрана соответствующая опция в настройках

##Сценарий использования:
Представим, что организация имеет необходимость в обеспечении работников множеством различных документов(какие-либо инструкции, какая-то документация и т.д.), доступ к которым сотрудники должны иметь быстро и просто. В таком случае, организация настраивает сервер, маркирует объекты(это могут быть инструменты, детали, материалы) заготовленными штрих-кодами, и нумерует PDF-документы на сервере соответствующими кодами. Настраивает приложение и раздаёт работникам смартфоны. Когда сотруднику нужна информация об объекте, он сканирует штрих-код и документ скачивается с сервера. А если он был загружен и использован ранее, то будет показана локальная копия.

##Подготовка к работе
**Требования**
Для работы системы необходимо клиентское устройство с версией операционной системы IOS не нижe 16.0 и любой сервер, отправляющий PDF-документы по GET-запросу.
Я написал свой на express.js, и выглядит он так:

````
const express = require("express")
const app = express()

app.get("/*", function(request, response){
    response.sendFile(__dirname + request.url + ".pdf")
})

app.listen(3000)
````


PDF-файлы с именами, соответствующими их штрих-кодам должны быть доступными по такой форме ссылки:

````
http(s)://адрес:порт/номер
````

Номер - число, закодированное в отсканированном штрих-коде и название PDF-файла на сервере соответственно.

**С сервером определились, приложение установили. Что дальше?**
Теперь подготовим сами файлы. Нужно дать им название в соответствии с штрих-кодами. А потом положить в корневую папку сервера.

Для генерации штрих-кодов в свободном доступе есть множество онлайн-сервисов. PDFinder считывает штрих-коды типа code128, так как они наиболее распространены. Но если требуется чтение других типов, то в файле  */PDFinder/scan/scanVM* в функции setUp можно найти эту строку

````
codeOutput.metadataObjectTypes = [.code128]
````
и добавить в массив недостающие типы.


**Последний штрих**
Когда сервер доступен, содержит необходимые PDF-файлы с правилными именами, на смартфон установлено приложение, а штрих-коды распечатаны и наклеены на нужные предметы, для работы остаётся только настроить приложение. Это можно сделать, перейдя в настройки со стартового экрана.
Для того, чтобы система начала работать, необходимо узнать адрес машины в сети, на которой выполняется серверная программа, и вписать его в пункт *Адрес сервера*. Если форма не подходит, то можно вписать адрес в обычную строку, выбрав параметр *Использовать обычную адресную строку*.
После этой настройки может потребоваться дать разрешение на поиск устройств в локальной сети.


**Режим работы с дубликатами**
По желанию можно настроить параметр *Режим работы с дубликатами*. Каждый из четырёх параметров определяет поведение программы, когда был отсканирован штрих-код документа, который уже сохранён в локальной базе данных. Выбирать предстоит из: *"Всегда спрашивать", "Локальный поиск", "Всегда сохранять" и "Заменять на новый"*.


##Использованные технологии

Клиентская часть:
- SwiftUI
- CoreData
- AVKit
- PDFKit
- Alamofire

Серверная часть:
- nodejs
- express


##Актуальные проблемы проекта
PDFinder - мой первый комплексный pet-проект. Я узнал много новых вещей, работая над ним. Но некоторые проблемы этого проекта остались нерешённой загадкой:

1. Расход памяти.
Всякий раз, когда данные скачиваются с сервера, на размере памяти занятой приложением это сказывается в двойном размере. При удалении этой записи из базы данных освобождается только половина памяти, занятой этом документом до удаления.
2. Вылеты
Когда размер приложения достигает 1-1.5 ГБ, при попытке зайти в настройки приложения или в список локальных документов, происходит вылет. Помогает только полное удаление приложения.

Никогда не обращал внимания на размер данных, хранимых в CoreData до момента, когда размеры записываемой информации выросли до сотен мегабайт. Если кто-то читает это и знает в чём проблема - расскажите мне.
